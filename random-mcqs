

var x=10
function printing(){
    console.log("x is " , x)
    
}
printing() //first execute this line
console.log("x from outer scope", x)  // second executes this

Hoisting

// Hoisting in js is a feature to access the variables before they intialised

printing()
console.log("x from outer scope", x)                                      
console.log(printing)
var x=10
function printing(){                                        //doesnot work with arrow functions ,expressions because they stored as vars in GEC.
    console.log("x is " , x)  
    console.log("hii shammu")
    }
output  
x is  undefined
hii shammu    //the function is executing means hoisted
x from outer scope undefined
[Function: printing]

//The scope of the variables

const x=20
a()
b()
console.log("x from local space is", x) // look for local var
function a(){
    var x=5
    console.log(x)
}  //gec vanished after execution


function b(){
    var x=10
    console.log(x)
} // gec is vanished after execution in call stack
output:
5
10
20

//the b is undefined the function is calling before and gec is created after the 
a()
const b=10

function a(){
    console.log("the var is ", b)
}
//lexical scope --- the scope where we can access the variables
var b=10
a()
function a(){
    // console.log("the var is ", b)
    c()
    
    function c(){
        console.log("the var from c", b)
    }
}



//The closure means the function remembers its lexical scope even after executing the outer funciom

function a(){
    const c=10
function b(){
    console.log("the c from outer function is" ,c)
    
}
return b
}
const c=a()()
//The function bundles with its lexical scope is called closure.
function a(){
    let  c=10
function b(){
    console.log("the c from outer function is" ,c)
    
}
 c=100
return b
}
const c=a()()   // it remembers the lexical scope reference to that variable


function x(){
    
    for(var i=0;i<5;i++){
         setTimeout(function(){
        console.log("i is", i)
    }, i*1000)
    }
    }
x()  // it prints all 5 because of the lexical scope and the reference shared by each function for execution is same
